from typing import Dict, List, Optional, Tuple
import random
import argparse
import sys

# -------------------------
# Shamir Secret Sharing (Erasure Code)
# -------------------------

_PRIME = 2**127 - 1  # Large prime for finite field arithmetic

def _eval_polynomial(coeffs: List[int], x: int, prime: int) -> int:
    # Evaluate a polynomial at point x over a prime field
    result = 0
    for power, coef in enumerate(coeffs):
        result = (result + coef * pow(x, power, prime)) % prime
    return result

def ECEnc(n: int, k: int, secret: int) -> List[Tuple[int, int]]:
    """Generate n shares (x, y) from secret with threshold k."""
    if not (0 <= secret < _PRIME):
        raise ValueError("Secret out of range")
    # Create a random polynomial with secret as the constant term
    coeffs = [secret] + [random.randrange(_PRIME) for _ in range(k - 1)]
    # Generate n (x, y) shares by evaluating polynomial at x=1 to x=n
    shares = [(i, _eval_polynomial(coeffs, i, _PRIME)) for i in range(1, n + 1)]
    print(f"[ECEnc] Generated shares: {shares}")
    return shares

def _lagrange_interpolate(x: int, x_s: List[int], y_s: List[int], prime: int) -> int:
    # Reconstruct the polynomial's value at x using Lagrange interpolation
    total = 0
    k = len(x_s)
    for i in range(k):
        xi, yi = x_s[i], y_s[i]
        num, den = 1, 1
        for j in range(k):
            if i != j:
                xj = x_s[j]
                num = (num * (x - xj)) % prime
                den = (den * (xi - xj)) % prime
        inv_den = pow(den, prime - 2, prime)  # Compute modular inverse
        total = (total + yi * num * inv_den) % prime
    return total

def ECDec(n: int, k: int, shares: List[Tuple[int, int]]) -> int:
    """Recover secret from any k shares."""
    x_s, y_s = zip(*shares[:k])
    secret = _lagrange_interpolate(0, list(x_s), list(y_s), _PRIME)
    print(f"[ECDec] Recovered secret from {shares[:k]}: {secret}")
    return secret

# -------------------------
# Reliable Broadcast
# -------------------------

NODES: Dict[int, "OciorABAStarNode"] = {}  # Global registry of all nodes

class RBC:
    def __init__(self, owner: int):
        self.owner = owner

    def broadcast(self, share: Tuple[int, int]):
        # Broadcast a share to all nodes
        print(f"[RBC] Node {self.owner} broadcasting {share}")
        for node in NODES.values():
            node.on_rbc_delivery(self.owner, share)

# -------------------------
# Byzantine-Tolerant ABBA Stub
# -------------------------

class ABBA:
    def __init__(self, owner: int, n: int, t: int):
        self.owner = owner
        self.n = n
        self.t = t
        self.inputs: Dict[int, int] = {}  # sender_id -> vote
        self._output: Optional[int] = None

    def input(self, sender: int, v: int):
        # Accept a binary vote from a sender
        if sender in self.inputs:
            return
        self.inputs[sender] = v
        print(f"[ABBA-{self.owner}] Received vote {v} from Node {sender}")
        self._try_decide()

    def _try_decide(self):
        # Try to reach consensus based on received votes
        if self._output is not None:
            return
        ones = sum(1 for v in self.inputs.values() if v == 1)
        zeros = sum(1 for v in self.inputs.values() if v == 0)
        if ones >= self.t + 1:
            self._output = 1
            print(f"[ABBA-{self.owner}] Decided 1 (ones={ones})")
        elif zeros >= self.n - self.t:
            self._output = 0
            print(f"[ABBA-{self.owner}] Decided 0 (zeros={zeros})")

    def has_output(self) -> bool:
        # Check if this ABBA instance has made a decision
        return self._output is not None

    def get_output(self) -> Optional[int]:
        # Get the decision (0 or 1)
        return self._output

# -------------------------
# OciorABA⋆ Node
# -------------------------

class OciorABAStarNode:
    def __init__(self, node_id: int, n: int, t: int):
        self.id = node_id
        self.n = n
        self.t = t
        self.vi: Dict[int, Optional[int]] = {j: None for j in range(1, n + 1)}  # Votes from each node
        self._shares: List[Tuple[int, int]] = []  # Shares generated by this node
        self.rbc = RBC(node_id)
        self.abba: Dict[int, ABBA] = {j: ABBA(j, n, t) for j in range(1, n + 1)}  # ABBA per sender
        self.abba_out: Dict[int, int] = {}  # Final outputs from each ABBA instance
        NODES[node_id] = self

    def propose(self, secret: int) -> None:
        # Propose a secret by encoding it and broadcasting one share
        print(f"\n[Node {self.id}] Proposing secret {secret}")
        self._shares = ECEnc(self.n, self.t + 1, secret)
        x_i, y_i = self._shares[self.id - 1]
        self.rbc.broadcast((x_i, y_i))

    def on_rbc_delivery(self, sender: int, share: Tuple[int, int]) -> None:
        # Handle a received share from another node
        if not self._shares:
            return
        x_j, y_jj = share
        x_i_j, y_i_j = self._shares[sender - 1]
        assert x_i_j == x_j  # Ensure x values match
        print(f"[Node {self.id}] Received share from Node {sender}: {share}")
        vote = 1 if y_jj == y_i_j else 0  # Vote 1 if share matches expected
        self.vi[sender] = vote
        print(f"[Node {self.id}] Vote for Node {sender} = {vote}")
        self.abba[sender].input(self.id, vote)
        self._process_abba()

    def _process_abba(self):
        # Process ABBA decisions and inject default votes if needed
        for j, ab in self.abba.items():
            if j not in self.abba_out and ab.has_output():
                self.abba_out[j] = ab.get_output()  # type: ignore
                print(f"[Node {self.id}] ABBA[{j}] output = {self.abba_out[j]}")
        if len(self.abba_out) >= self.n - self.t:
            for j in range(1, self.n + 1):
                if j not in self.abba_out:
                    self.abba[j].input(self.id, 0)  # Force 0 if undecided
        if len(self.abba_out) == self.n:
            self._finalize()

    def _finalize(self):
        # Finalize the decision based on ABBA outputs
        Aones = {j for j, v in self.abba_out.items() if v == 1}
        print(f"[Node {self.id}] Aones = {Aones}")
        if len(Aones) < self.t + 1:
            print(f"[Node {self.id}] Decides ⊥")  # Not enough valid shares
            return
        Bones = sorted(Aones)[: self.t + 1]  # Select t+1 valid shares
        print(f"[Node {self.id}] Bones = {Bones}")
        shares = [self._shares[j - 1] for j in Bones]
        recovered = ECDec(self.n, self.t + 1, shares)  # Reconstruct the secret
        print(f"[Node {self.id}] Decides {recovered}")

# Funtion for passing in command line arguments

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Ocior ABA⋆ Algorithm 1 Demo")
    parser.add_argument("-n", "--nodes", type=int, default=4,
                        help="Number of nodes (default: 4)")
    parser.add_argument("-t", "--faults", type=int, default=1,
                        help="Maximum faulty nodes tolerated (default: 1)")
    return parser.parse_args()

if __name__ == "__main__":
    cfg = parse_args()
    n, t = cfg.nodes, cfg.faults

    if n < 3 * t + 1:
        sys.exit("Error: n must be at least 3t + 1 for Byzantine fault tolerance")

    NODES.clear()
    for i in range(1, n + 1):
        OciorABAStarNode(i, n=n, t=t)

    secret = 2025
    print(f"\n=== Simulation Start: n={n}, t={t}, secret={secret} ===")
    for i in range(1, n + 1):
        NODES[i].propose(secret)